#!/usr/bin/env perl
# vim: set tabstop=4:
#
# Copyright (c) 2012 Marcel Kaiser. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
##############################################################################
# PURPOSE:	Creates and updates the Openbox menu.
# REQUIRES:	Optional: notify-send, gmessage or xmessage for error messages.
##############################################################################
use utf8;
use strict;
use Fcntl qw(:flock);
use IO::KQueue;

my %category_icons = (
	AudioVideo  => "applications-multimedia",
	Audio	    => "applications-multimedia",
	Video	    => "applications-multimedia",
	Development => "applications-development",
	Education   => "applications-science",
	Game	    => "applications-games",
	Graphics    => "applications-graphics",
	Network	    => "applications-internet",
	Office	    => "applications-office",
	Settings    => "preferences-system",
	System	    => "applications-system",
	Utility	    => "applications-utilities",
	Application => "applications-other"
);

my @categories = (
	"AudioVideo", "Audio",    "Video",    "Development",
	"Education",  "Game",     "Graphics", "Network",
	"Office",     "Settings", "System",   "Utility"
);

# Add your language here.
my %ctgrs_de = (
	AudioVideo => "Audio/Video", Audio       => "Audio",
	Video	   => "Video",       Development => "Entwicklung",
	Education  => "Bildung",     Game        => "Spiele",
	Graphics   => "Grafik",      Network     => "Netzwerk/Internet",
	Office	   => "Büro",        Settings    => "Einstellungen",
	System	   => "System",      Utility     => "Zubehör",
	Application=> "Anwendungen"
);

my %ctgrs_fr = (
	AudioVideo => "Audio/Video", Audio       => "Audio",
	Video      => "Video",       Development => "Développement",
	Education  => "Éducation",   Game        => "Jeu",
	Graphics   => "Graphique",   Network     => "Réseau",
	Office     => "Bureau",      Settings    => "Réglages",
	System     => "Système",     Utility     => "Utilitaire",
	Application=> "Application"
);

my %ctgrs_es = (
	AudioVideo => "Audio/Video", Audio       => "Audio",
	Video      => "Video",       Development => "Desarrollo",
	Education  => "Educación",   Game        => "Juego",
	Graphics   => "Gráficos",    Network     => "Red",
	Office     => "Oficina",     Settings    => "Ajustes",
	System     => "Sistemas",    Utility     => "Utilidad",
	Application=> "Solicitud"
);

my %ctgrs_gr = (
	AudioVideo => "Ήχος/βίντεο", Audio       => "Ήχος",
	Video      => "βίντεο",      Development => "Ανάπτυξη",
	Education  => "Εκπαίδευση",  Game        => "Παιχνίδι",
	Graphics   => "Γραφικά",     Network     => "Δίκτυο",
	Office     => "Γραφείο",     Settings    => "Ρυθμίσεις",
	System     => "Σύστημα",     Utility     => "Χρησιμότητα",
	Application=> "Εφαρμογή"
);

my %ctgrs_pt = (
	AudioVideo => "Áudio/Vídeo", Audio       => "Áudio",
	Video      => "Vídeo",       Development => "Desenvolvimento",
	Education  => "Educação",    Game        => "Jogos",
	Graphics   => "Gráficos",    Network     => "Rede",
	Office     => "Escritório",  Settings    => "Definições",
	System     => "Sistema",     Utility     => "Utility",
	Application=> "Aplicação"
);

my %ctgrs_ru = (
	AudioVideo => "Аудио/видео", Audio       => "аудио",
	Video      => "видео",       Development => "развитие",
	Education  => "образование", Game        => "Игра",
	Graphics   => "Графика",     Network     => "сеть",
	Office     => "офис",        Settings    => "настройки",
	System     => "система",     Utility     => "Полезность",
	Application=> "заявка"
);

my %ctgrs_zh = (
	AudioVideo => "音頻視頻",      Audio       => "音頻",
	Video      => "視頻",         Development => "發展",
	Education  => "教育",         Game        => "遊戲",
	Graphics   => "圖像",         Network     => "網絡",
	Office     => "辦公室",       Settings    => "設置",
	System     => "系統",         Utility     => "效用",
	Application=> "應用"
);

my %ctgrs_jp = (
	AudioVideo => "オーディオ/ビデオ", Audio       => "オーディオ",
	Video      => "ビデオ",          Development => "開発",
	Education  => "教育",            Game        => "ゲーム",
	Graphics   => "グラフィックス",    Network     => "ネットワーク",
	Office     => "事務所",          Settings    => "設定",
	System     => "システム",        Utility      => "効用",
	Application=> "応用"
);

my %ctgrs = (
	de => \%ctgrs_de,
	es => \%ctgrs_es,
	fr => \%ctgrs_fr,
	gr => \%ctgrs_gr,
	jp => \%ctgrs_jp,
	pt => \%ctgrs_pt,
	ru => \%ctgrs_ru,
	zh => \%ctgrs_zh
);

my @xterms= (
	"sakura", "urxvt", "rxvt", "mrxvt", "xterm", "Terminal",
	"gnome-terminal"
);

# Where to look for desktop files.
my @apps_paths = (
	"/usr/local/share/applications", "/usr/share/applications",
	$ENV{'XDG_DATA_HOME'} ? $ENV{'XDG_DATA_HOME'} :
		"$ENV{'HOME'}/.local/share/applications",
	$ENV{'XDG_DATA_HOME'} ? $ENV{'XDG_DATA_HOME'} :
		"$ENV{'HOME'}/.local/applications"
);

# Paths to look for icon dirs.
my @icon_prefix = (
	"/usr/local/share/icons",
	"/usr/share/icons",
	"$ENV{HOME}/.icons",
	"$ENV{'HOME'}/.local/share/icons"
);

# Pixmaps paths
my @pixmap_search_paths = (
	"/usr/local/share/icons",
	"/usr/local/share/pixmaps",
	"/usr/share/pixmaps",
	"/usr/share/icons",
	"$ENV{'HOME'}/.fluxbox/icons",
	"$ENV{'HOME'}/.local/share/pixmaps",
);

my @toolkit_config_paths = (
	"$ENV{'HOME'}/.config/gtk-3.0/settings.ini",
	"$ENV{'HOME'}/.gtkrc-2.0",
	"$ENV{'HOME'}/.gtkrc-2.0.mine",
	"$ENV{'HOME'}/.gtkrc.mine",
	"$ENV{'HOME'}/.config/qt5ct/qt5ct.conf"
);

my $lang                = "en";
my $lockfile            = "$ENV{'HOME'}/.update_obmenu.lock";
my $menu_path           = "$ENV{'HOME'}/.config/openbox/menu.xml";
my @menu_prefix         = ("/etc", "/usr/etc", "/usr/local/etc");
my $dflt_menu           = "xdg/openbox/menu.xml";
my $fallback_icon_theme = "hicolor";
my ($progname, $icon_theme, $xterm);
my (@ob_menu, @blacklist, @apps, @icon_search_paths);
my %cats_hash;

##############################################################################
sub Xerr {
	my ($ret, $msg) = @_;
	$msg = "$progname: $msg";
	print STDERR "$msg\n";
	unless (system("notify-send -u critical \"$msg\"") == 0) {
		system("xmessage \"$msg\"") if (system("gmessage \"$msg\"") == -1);
	}
	exit($ret);
}

sub translate {
	my ($str) = @_;
	my ($l, $p, $tstr);

	return ($str) if (!$lang || $lang eq 'en');
	($l) = split(/_/, $lang, 2);
	return ($str) if (!($p = $ctgrs{$l}));
	$tstr = ${$p}{$str};
	utf8::encode($tstr);
	return ($tstr);
}

sub find_xterm {
	my ($t, $path);

	foreach $t (@xterms) {
		foreach $path (split(/:/, $ENV{'PATH'})) {
			if (-x "$path/$t")
				{ $xterm = "$path/$t -e"; return ($xterm); }
		}
	}
	return ("");
}

sub lookup_icon_theme {
	my $fh;
	local $_;

	$icon_theme = "";
	foreach my $path (@toolkit_config_paths) {
		open($fh, '<', $path) or next;
		foreach (<$fh>) {
			if (/^gtk-icon-theme-name\s*=\s*\"(.+)\"/) {
				$icon_theme = $1;
			} elsif (/^gtk-fallback-icon-theme\s*=\s*\"(.+)\"/) {
				$fallback_icon_theme = $1;
			} elsif (/^icon_theme\s*=\s*(.+)/) {
				$icon_theme = $1;
			}
		}
		close($fh);
		return (0) if ($icon_theme);
	}
	return (-1);
}

sub get_inherits {
	my ($fh);
	my ($index) = "$_[0]/index.theme";
	local $_;

	return if (! -f $index);
	open($fh, '<', $index) || return;
	foreach (<$fh>) {
		if (/^Inherits=(.*)/) {
			close($fh);
			return split(/\,/, $1);
		}
	}
	close($fh);
}

sub find_icon_theme_dir {
	my ($theme) = @_;
	local $_;

	foreach (@icon_prefix) {
		my $dir = "$_/$theme";
		return $dir if (-d $dir);
	}
	return "";
}

sub get_icon_search_paths {
	my ($dir, $idir, $fh);
	my (@list, @icon_paths);
	local $_;

	if (!$icon_theme) {
		lookup_icon_theme();
	}
	if (($dir = find_icon_theme_dir($icon_theme))) {
		push @icon_paths, $dir;
		my @inherits = get_inherits($dir);
		foreach my $ih (@inherits) {
			my $ihdir = find_icon_theme_dir($ih);
			push @icon_paths, $ihdir if ($ihdir);
		}
	}
	if (($dir = find_icon_theme_dir($fallback_icon_theme))) {
		push @icon_paths, $dir;
		my @inherits = get_inherits($dir);
		foreach my $ih (@inherits) {
			my $ihdir = find_icon_theme_dir($ih);
			push @icon_paths, $ihdir if ($ihdir);
		}
	}
	foreach $dir (@icon_paths) {
		open($fh, '<', "$dir/index.theme") or next;
		foreach (<$fh>) {
			if (/^\[(.+)\]/) {
				$idir = $1;
			} elsif (/^Size=(.+)/) {
				if ($1 >= 16) {
					push @list, "$dir/$idir";
				}
			}
		}
		close $fh;
	}
	push @icon_search_paths, @list;
	push @icon_search_paths, @pixmap_search_paths;
}

sub find_icon {
	my ($i, $ih, $p, $path, $dir, @inherit, @tmp);
	my ($icon) = @_;
	my @exts = ('.svg', '.png', '.xpm');
	local $_;

	if ($icon !~ /.*\.(svg|png|xpm)$/) {
		for ($i = 0; $i < @exts; $i++) {
			$p = $icon . $exts[$i];
			foreach $dir (@icon_search_paths) {
				return "$dir/$p" if (-f "$dir/$p");
			}
			foreach $dir (@icon_search_paths) {
				foreach (glob(qq(${dir}/${icon}*))) {
					return "$_" if (-f "$_");
				}
			}
		}
	} else {
		foreach $dir (@icon_search_paths) {
			return "$dir/$icon" if (-f "$dir/$icon");
		}
	}
}

sub find_menu {
	my ($id) = @_;
	my $idx  = 0;
	local $_;

	foreach (@ob_menu) {
		return ($idx) if (/^\s*\<menu id=\"$id\"/);
		$idx++;
	}
	return (-1);
}

sub find_application {
	my ($app) = @_;
	local $_;

	foreach (@ob_menu) {
		return (1) if (/^\s*\<item label=\"$app\"/);
	}
	return (0);
}

sub parse_desktop_file {
	my ($fname) = @_;
	my %info;
	my ($fh, $type, $default_comment, $default_name, $terminal, $command);
	my ($lang1, $lang2, $name, $comment, $category, $path, $icon, $x);
	my ($no_display, $dt_entry_section);
	local $_;

	$lang1 = $lang;
	$lang2 = ($lang =~ /(.*)_/) ? $1 : $lang;

	$info{'Filename'} = $fname;

	open($fh, '<', $fname) or return (0);

	$name = $comment = $category = "";
	foreach (<$fh>) {
		if (!$dt_entry_section) {
			$dt_entry_section = 1 if ($_ =~ /^\[Desktop Entry\]/);
			next;
		}
		last if ($_ =~ /^\[/); 

		$default_name= $1 if (/^_?Name\s*=\s*(.*)/);
		$name		 = $1 if (/^_?Name\[$lang1\]\s*=\s*(.*)$/ ||
							/^_?Name\[$lang2\]\s*=\s*(.*)$/);
		$default_comment = $1 if (/^_?Comment\s*=\s*(.*)/);
		$comment	 = $1 if (/^_?Comment\[$lang1\]\s*=\s*(.*)/ ||
							/^_?Comment\[$lang2\]\s*=\s*(.*)/);
		$command	 = $1 if (/^Exec\s*=\s*(.*)$/);
		$type		 = $1 if (/^Type\s*=\s*(.*)/);
		$terminal	 = $1 if (/^Terminal\s*=\s*(.*)/);
		$path		 = $1 if (/^Path\s*=\s*(.*)/);
		$icon		 = $1 if (/^Icon\s*=\s*(.*)$/);
		$no_display	 = $1 if (/^NoDisplay\s*=\s*(.*)$/);
		if (/^Categories\s*=(\S*)/) {
			foreach $x (split(/;/, $1)) {
				foreach (@categories)
					{ $category = $_ if ($_ eq $x); }
				last if ($category);
			}
		}
	}
	chomp($category);

	close($fh);
	return (0) if ($type ne "Application");

	$command =~ s/\%[a-z,A-Z]//;
	$info{'Icon'}	  = $icon; 
	$info{'Name'}	  = $name ? $name : $default_name;
	$info{'Comment'}  = $comment ? $comment : $default_comment;
 	$info{'Type'}	  = $type;
	$info{'Terminal'} = $terminal;
	$info{'Exec'}	  = $command;
	$info{'Category'} = $category ? $category : "Application";
	$info{'Path'}	  = $path;
	$info{'NoDisplay'}= lc($no_display);
	return (%info);
}

sub add_submenu {
	my ($id, $label)  = @_;
	my $idx   = 0;
	my $label = translate($id);
	my $icon  = find_icon($category_icons{$id});
	local $_;

	foreach (@ob_menu) {
		last if (/^\<openbox_menu/);
		$idx++;
	}
	if ($idx == @ob_menu) {
		Xerr(1, "Fatal: Coudn't find 'openbox_menu'\n" .
			"Your menu.xml seems to be corrupted.");
	}
	splice @ob_menu, $idx + 1, 0,
		   "<menu id=\"$id\" label=\"$label\" comment=\"--- auto ---\">";
	splice @ob_menu, $idx + 2, 0, "</menu>";
	if (($idx = find_menu("root-menu")) == -1)
		{ Xerr(1, "Fatal: Couldn't find the root menu") }
	splice @ob_menu, $idx + 1, 0, "\t<menu id=\"$id\" icon=\"$icon\" " .
		   "comment=\"--- auto ---\"/>";
	return (0);
}

sub add_application {
	my (%app) = @_;
	my ($i, $xterm, $icon);
	local $_;

	return (-1) if (($i = find_menu($app{'Category'})) == -1);
	
	if ($app{'Terminal'} && $app{'Terminal'} ne 'false') { 
		$xterm = find_xterm();
		$app{'Exec'} = "$xterm $app{'Exec'}"
	}
	if ($app{'Icon'}) {
		if ($app{'Icon'} !~ /^\/.*/) {
			$icon = find_icon($app{'Icon'});
		} else {
			$icon = $app{'Icon'};
		}
		if ($icon) {
			$icon = "$icon".".png"
				if ($icon !~ /.*\.[a-zA-Z]+$/);
			splice @ob_menu, $i + 1, 0,
				   "\t<item icon=\"$icon\"" .
				   " label=\"$app{'Name'}\" " .
				   "comment=\"--- auto ---\">";
		} else {
			splice @ob_menu, $i + 1, 0,
				   "\t<item label=\"$app{'Name'}\" " .
				   "comment=\"--- auto ---\">";
		}
	} else {
		splice @ob_menu, $i + 1, 0, "\t<item label=\"$app{'Name'}\" " .
			   "comment=\"--- auto ---\">";
	}
	splice @ob_menu, $i + 2, 0, "\t\t<action name=\"Execute\">";
	splice @ob_menu, $i + 3, 0, "\t\t\t<command>$app{'Exec'}</command>";
	splice @ob_menu, $i + 4, 0, "\t\t</action>";
	splice @ob_menu, $i + 5, 0, "\t</item>";

	return (0);
}

sub add_me {
	my $idx = 0;
	my $found_root_menu = 0;
	local $_;

	foreach (@ob_menu) {
		if (/^\<menu id=\"root-menu\"/) {
			$found_root_menu = 1;
		} elsif ($found_root_menu == 1 && /^\<\/menu\>/) {
			last;
		}
		$idx++;
	}
	return if ($idx == @ob_menu);
	splice @ob_menu, $idx + 0, 0,
	    "\t<item label=\"Update Menu\" comment=\"--- auto ---\">";
	splice @ob_menu, $idx + 1, 0, "\t\t<action name=\"Execute\">";
	splice @ob_menu, $idx + 2, 0,
	    "\t\t\t<command>$0 -u<\/command>";
	splice @ob_menu, $idx + 3, 0, "\t\t<\/action>";
	splice @ob_menu, $idx + 4, 0, "\t<\/item>";
}

sub read_blacklist {
	my $path_blacklist = "$ENV{HOME}/.config/update_obmenu.ignore";

	return if (! -f $path_blacklist);

	open(my $fh, '<', $path_blacklist)
		or die "Failed to open $path_blacklist";
	@blacklist = <$fh>;

	close($fh);
}

sub is_blacklisted {
	my ($f) = @_;
	local $_;

	foreach (@blacklist) {
		chomp;
		return 1 if ($f eq $_);
	}
	return 0;
}

sub read_obmenu {
	my ($fh, $skip_item, $skip_menu, $buf, @lines);
	local $_;

	@ob_menu = ();
	# Read the obenbox menu and skip previously added menus and
	# application entries.
	if (!open($fh, '<', $menu_path) and !open($fh, '<', $dflt_menu))
		{ Xerr(1, "Could not find menu.xml") }
	flock($fh, LOCK_EX)
		or Xerr(1, "Could not lock $menu_path");
	foreach (<$fh>) {
		$_ =~ s/>\s*</>\n</g;
		$buf .= $_;
	}
	@lines = split(/\n/, $buf);

	$skip_item = $skip_menu = 0;
	foreach (@lines) {
		chomp;
		next if (!$_ || /^\s*$/);
		if (/\s*<menu\s*.*\s*comment=\"--- auto ---\">/) {
			$skip_menu = 1;
		} elsif (/\s*<item\s*.*\s*comment=\"--- auto ---\">/) {
			$skip_item = 1;
		} elsif ($skip_menu && /\s*<\/menu>/) {
			$skip_menu = 0;
		} elsif ($skip_item && /\s*<\/item>/) {
			$skip_item = 0;
		} else {
			next if ($skip_item || $skip_menu);
			next if (/\s*<menu\s*.*\s*comment=\"--- auto ---\".*\/>/);
			push @ob_menu, $_;
		}
	}
	flock($fh, LOCK_UN);
	close($fh);
}

sub write_obmenu {
	my $fh;
	local $_;

	chmod(0644, $menu_path);
	open($fh, '>', $menu_path)
		or Xerr(1, "Could not open \'$menu_path\'");
	flock($fh, LOCK_EX)
		or Xerr(1, "Could not lock $menu_path");
	foreach(@ob_menu) {
		chomp;
		print $fh "$_\n"
	}
	flock($fh, LOCK_UN);
	close($fh);
	system("openbox --reconfigure");
}

#
# Take an array of flag character and the expected number of arguments.
# If $ARGV[0] containes a flag not in the given array, or @ARGV doesn't
# have the required number of arguments, exit with an error.
# If $ARGV[0] contains a valid flag and @ARGV has the expected number of
# arguments, return the flag character and an array with its arguments.
# If $ARGV[0] doesn't start with a '-', return an empty string.
#
sub getargs {
	my ($nargs, $i);
	local $_;

	if ($ARGV[0] =~ /^-([A-Za-z0-9])([A-Za-z0-9]+)/) {
		# -Xarg or -XYZ == -X -Y -Z
		$nargs = @ARGV;
		for ($i = 0; $i < @_ - 1; $i++) {
			next if ($_[$i] ne $1);
			if ($_[$i + 1] == 0) {
				my $opt = $1;
				$ARGV[0] =~ s/^-$opt(.*)/-$1/;
				return (($opt));
			}
			last;
		}
		if ($i == @_ - 1) {
			print STDERR "Invalid option '-$1'\n";
			exit 1;
		}
		for (my $j = 0; $j + 1 < $nargs && $j < $_[$i + 1]; $j++) {
			if ($ARGV[$j + 1] =~ /^-/) {
				print STDERR "Option -$_[$i] requires $_[$i + 1] argument(s)\n";
				exit 1
			}
		}
		my @args = ($2);
		push @args, splice(@ARGV, 1, $_[$i + 1] - 1);
		if (@args < $_[$i + 1]) {
			print STDERR "Option -$_[$i] requires $_[$i + 1] argument(s)\n";
			exit 1
		}
		shift @ARGV;
		return (($1, @args));
	} elsif ($ARGV[0] =~ /^-([A-Za-z0-9]{1})/) {
		# -X
		$nargs = @ARGV - 1;
	} else {
		return ();
	}
	for ($i = 0; $i < @_ - 1; $i++) {
		next if ($_[$i] ne $1);
		if ($nargs < $_[$i + 1]) {
			print STDERR "Option -$_[$i] requires $_[$i + 1] arguments\n";
			exit 1;
		}
		for (my $j = 0; $j + 1 < $nargs && $j < $_[$i + 1]; $j++) {
			if ($ARGV[$j + 1] =~ /^-/) {
				print STDERR "Option -$_[$i] requires $_[$i + 1] arguments\n";
				exit 1
			}
		}
		my @args = splice(@ARGV, 1, $_[$i + 1]);
		shift @ARGV;
		return (($1, @args));
	}
	print STDERR "Invalid option '$ARGV[0]'\n";
	exit 1;
}

sub usage {
	print STDERR "Usage: $progname [-i theme] -u|-n|-a [-p delay]\n" .
			 "-a   : Monitor application directories and autoupdate menu.\n" .
			 "-p   : Instead of kqueue use stat to poll for changes every " .
			 "'delay' seconds.\n" .
			 "-u   : Update your Openbox menu.\n" .
		     "-n   : Create a new Openbox menu. Your old menu.xml " .
			 "will be overwritten!\n" .
			 "-i   : Use the given icon theme.\n";
	exit(1);
}

##############################################################################
my ($aflag, $nflag, $uflag, $pflag, $delay, $update);
my ($path, $kq, $lock);
my (@fhs, @mtimes);

($lang) = split(/\./, $ENV{'LANG'});

if ($0 =~ /\.{0,2}.*\/([a-zA-Z0-9.,-_]+$)/) {
	$progname = $1;
} else {
	$progname = $0;
}

# Look for the default openbox menu
foreach (@menu_prefix) {
	my $path = "${_}/${dflt_menu}";

	if (-e $path) {
		$dflt_menu = $path;
		last;
	}
}

while ((my ($flag, @args) = getargs(qw(n 0 h 0 u 0 a 0 p 1 i 1)))) {
	usage()	   if ($flag eq 'h');
	$aflag = 1 if ($flag eq 'a');
	$uflag = 1 if ($flag eq 'u');
	$nflag = 1 if ($flag eq 'n');
	if ($flag eq 'p') {
		$pflag = 1;
		$delay = $args[0];
	} elsif ($flag eq 'i') {
		$icon_theme = $args[0];
	}
}

if ($aflag == 0) {
	if (($uflag == 1 && $nflag == 1) || ($uflag == 0 && $nflag == 0)) {
		usage();
	}
} elsif ($aflag + $nflag + $uflag > 1) {
	usage();
} elsif ($pflag && !$aflag) {
	usage();
}

if ($nflag == 1) {
	# Create a new menu.
	@ob_menu = ();
	push @ob_menu, '<?xml version="1.0" encoding="UTF-8"?>';
	push @ob_menu, '<openbox_menu xmlns="http://openbox.org/3.4/menu">';
	push @ob_menu, '<menu id="root-menu" label="Openbox 3">';
	push @ob_menu, '<separator />' . "\n";
	push @ob_menu, '<menu id="client-list-menu" />';
	push @ob_menu, '<separator />';
	push @ob_menu, '<item label="Reconfigure">';
	push @ob_menu, '<action name="Reconfigure" />';
	push @ob_menu, '</item>';
	push @ob_menu, '<separator />';
	push @ob_menu, '<item label="Exit">';
	push @ob_menu, '<action name="Exit" />';
	push @ob_menu, '</item>';
	push @ob_menu, '</menu>';
	push @ob_menu, '</openbox_menu>';
} elsif (!$aflag) {
	read_obmenu();
}

# Remove non-existing paths
for (my $i = 0; $i < @apps_paths;) {
	if (! -d $apps_paths[$i]) {
		splice @apps_paths, $i, 1;
	} else {
		$i++;
	}
}

if ($aflag) {
	open($lock, '>>', $lockfile)
		or Xerr(1, "Failed to open lockfile");
	unless (flock($lock, LOCK_EX|LOCK_NB)) {
		print STDERR "Another instance of '$progname -a' is already running\n";
		exit(1);
	}
	seek $lock, 0, 0;
	print $lock "$$\n";
	$lock->flush();
	truncate $lock, tell($lock);

	if ($pflag) {
		for (my $i = 0; $i < @apps_paths; $i++) {
			my @r = stat($apps_paths[$i]);
			$mtimes[$i] = $r[9];
		}
	} else {
		$kq = IO::KQueue->new();
		foreach (@apps_paths) {
			if (open(my $fh, $_)) {
				push @fhs, $fh;
				my $fd = fileno($fh);
				$kq->EV_SET($fd, EVFILT_VNODE, EV_ADD|EV_ONESHOT,
							NOTE_WRITE, 0, 0);
			}
		}
	}
}

read_blacklist();
get_icon_search_paths();

while (1) {
	if ($aflag) {
		if ($pflag) {
			sleep($delay);
			for (my $i = 0; $i < @apps_paths; $i++) {
				my @r = stat($apps_paths[$i]);
				if ($mtimes[$i] != $r[9]) {
					$mtimes[$i] = $r[9];
					$update = 1;
				}
				sleep(1);
			}
			next if (!$update);
		} else {
			my @events = $kq->kevent();
			next if (!@events);
			foreach my $kevent (@events) {
				my $fd = $kevent->[KQ_IDENT];
				sleep(1);
				$kq->EV_SET($fd, EVFILT_VNODE, EV_ADD|EV_ONESHOT,
								 NOTE_WRITE, 0, 0);
			}
		}
		read_obmenu();
	}
	@apps = ();
	%cats_hash = ();
	foreach $path (@apps_paths) {
		foreach (`find $path -name "*.desktop" 2>/dev/null`) {
			chomp;
			next if (/userapp-/);
			next if (is_blacklisted($_));
			my %i;
			if ((%i = parse_desktop_file($_))) {
				next if (find_application($i{'Name'}));
				next if ($i{'NoDisplay'} eq 'true');
				if ($i{'Category'} && find_menu($i{'Category'}) == -1) {
					my $key = translate($i{'Category'});
					$cats_hash{$key} = $i{'Category'};
					push @apps, { %i };
				}
			}
		}
	}
	foreach (sort {$b cmp $a} keys %cats_hash) {
		next if (find_menu($cats_hash{$_}) != -1);
		add_submenu($cats_hash{$_});
	}
	foreach my $c (values %cats_hash) {
		my @capps;

		for (my $i = 0; $i < @apps; $i++) {
			next if ($c ne $apps[$i]{'Category'});
			my $j;
			for ($j = 0; $j < @capps; $j++) {
				if (lc($apps[$i]{'Name'}) le lc($capps[$j]{'Name'})) {
					splice @capps, $j, 0, $apps[$i];
					last;
				}
			}
			if ($j == @capps) {
				push @capps, $apps[$i];
			}
		}
		for (my $i = @capps - 1; $i >= 0; $i--) {
			next if (find_application($capps[$i]{'Name'}));
			my $hp = $capps[$i];
			my %h = %$hp;
			add_application(%h);
		}
		@capps = ();
	}
	last if (!$aflag);
	add_me();
	write_obmenu();
	$update = 0;
}

# Add an entry for this script to the Openbox root menu.
add_me();
write_obmenu();
exit(0);
